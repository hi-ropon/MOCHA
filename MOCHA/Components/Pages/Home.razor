@page "/"
@attribute [Authorize]
@using System
@using System.Collections.Generic
@using System.Linq
@using System.Security.Claims
@using System.Text.Encodings.Web
@using System.Text.Json
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.JSInterop
@using Microsoft.Extensions.Options
@using MOCHA.Agents.Infrastructure.Options
@using MOCHA.Models.Chat
@using MOCHA.Models.Feedback
@using MOCHA.Services.Chat
@using Microsoft.Extensions.Logging
@using System.Text
@using static MOCHA.Services.Chat.ActivityPanelService
@using static MOCHA.Services.Chat.ActivityBuilder
@inject MOCHA.Services.Chat.IChatRepository ChatRepository
@inject MOCHA.Services.Chat.IChatOrchestrator Orchestrator
@inject MOCHA.Services.Chat.ConversationHistoryState HistoryState
@inject MOCHA.Services.Agents.DeviceAgentState AgentState
@inject MOCHA.Services.Agents.PlcConnectionState PlcConnectionState
@inject MOCHA.Services.Chat.IChatAttachmentService AttachmentService
@inject IOptionsMonitor<LlmOptions> LlmOptions
@inject MOCHA.Services.Feedback.IFeedbackService FeedbackService
@inject MOCHA.Services.Markdown.IMarkdownRenderer MarkdownRenderer
@inject ILogger<Home> Logger
@inject IJSRuntime JS
@inject NavigationManager NavigationManager
@implements IDisposable

<PageTitle>M.O.C.H.A.</PageTitle>

<div class="chat-shell">
    <div class="chat-body">
        <main class="chat-main glass-card">
            <div class="messages" @ref="MessageList">
                @{
                    var userTurnCounter = -1;
                }
                @for (var i = 0; i < Messages.Count; i++)
                {
                    var message = Messages[i];
                    if (message.Role == ChatRole.User)
                    {
                        userTurnCounter++;
                    }

                    var turnActivity = message.Role == ChatRole.User
                        ? GetTurnActivityForTurn(userTurnCounter)
                        : null;
                    var hasLog = turnActivity?.Items.Any() == true;
                    var showInlineChip = message.Role == ChatRole.User && (hasLog || turnActivity?.IsLive == true);
                    var turnIndexForChip = userTurnCounter;
                    var messageIndex = i;
                    <div class="@GetBubbleClass(message.Role)">
                        <div class="content">
                            @if (message.Role == ChatRole.Assistant || message.Role == ChatRole.Tool)
                            {
                                <div class="markdown-body">@((MarkupString)RenderMarkdown(message.Content))</div>
                            }
                            else
                            {
                                @message.Content
                            }
                            @if (message.Attachments?.Any() == true && message.Role == ChatRole.User)
                            {
                                <div class="attachment-inline">
                                    @foreach (var attachment in message.Attachments)
                                    {
                                        <button class="attachment-thumb" @onclick="() => OpenLightbox(attachment)" aria-label="画像を拡大">
                                            <img src="@attachment.MediumBase64" alt="@attachment.FileName" />
                                        </button>
                                    }
                                </div>
                            }
                        </div>
                    </div>
                    @if (showInlineChip)
                    {
                        <div class="@GetChipClass(turnActivity)" @onclick="() => OpenActivityPanelForTurn(turnIndexForChip)" title="アクティビティを開く">
                            <div class="chip-header">
                                <span class="chip-title">思考過程</span>
                                <span class="chip-count">@GetChipCountLabel(turnActivity, hasLog)</span>
                            </div>
                        </div>
                    }
                    @if (ShouldShowFeedback(message, messageIndex, _streamingAssistantIndex))
                    {
                        <div class="feedback-actions">
                            @if (!IsRatedAs(messageIndex, FeedbackRating.Bad))
                            {
                                <button class="@GetFeedbackButtonClass(messageIndex, FeedbackRating.Good)" @onclick="() => SubmitFeedbackAsync(messageIndex, FeedbackRating.Good)" disabled="@IsFeedbackDisabled(messageIndex)" title="Good" aria-label="Good">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                        <path d="M2 10h4v12H2zM8 22h9a3 3 0 0 0 2.95-2.55l1-7A3 3 0 0 0 18 9h-5.63l.86-4.13A1.5 1.5 0 0 0 11.76 3l-4.4 6.29A2 2 0 0 0 7 10v10a2 2 0 0 0 2 2Z"/>
                                    </svg>
                                </button>
                            }
                            @if (!IsRatedAs(messageIndex, FeedbackRating.Good))
                            {
                                <button class="@GetFeedbackButtonClass(messageIndex, FeedbackRating.Bad)" @onclick="() => SubmitFeedbackAsync(messageIndex, FeedbackRating.Bad)" disabled="@IsFeedbackDisabled(messageIndex)" title="Bad" aria-label="Bad">
                                    <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                                        <path d="M2 2h4v12H2zM8 2h9a3 3 0 0 1 2.95 2.55l1 7A3 3 0 0 1 18 15h-5.63l.86 4.13A1.5 1.5 0 0 1 11.76 21l-4.4-6.29A2 2 0 0 1 7 14V4a2 2 0 0 1 2-2Z"/>
                                    </svg>
                                </button>
                            }
                        </div>
                    }
                }

                @if (!string.IsNullOrEmpty(Status))
                {
                    <div class="status-line">@Status</div>
                }
            </div>

            <div class="composer">
                @if (ComposerAttachments.Any())
                {
                    <div class="composer-attachments">
                        @foreach (var attachment in ComposerAttachments)
                        {
                            <div class="attachment-chip">
                                <img src="@attachment.SmallBase64" alt="@attachment.FileName" />
                                <div class="attachment-meta">
                                    <div class="name">@attachment.FileName</div>
                                    <div class="size">@FormatSize(attachment.Size)</div>
                                </div>
                                <button class="icon-btn tertiary" @onclick="() => RemoveAttachmentAsync(attachment.Id)" aria-label="添付を削除">✕</button>
                            </div>
                        }
                    </div>
                }

                <div class="composer-inner">
                    <div class="input-shell">
                        <label class="icon-btn secondary attach-btn" title="画像を追加">
                            ＋
                            <InputFile OnChange="HandleFileSelected" multiple accept="image/png,image/jpeg" class="file-input" />
                        </label>
                        <textarea class="chat-input" placeholder="メッセージを入力 (Enter または Ctrl+Enter で送信)"
                                  @ref="ComposerInput"
                                  @bind="Input"
                                  @bind:event="oninput"
                                  @onkeydown="HandleKeyDown"
                                  aria-multiline="true"
                                  rows="1"></textarea>
                        <div class="input-actions inline">
                            <button class="icon-btn secondary" @onclick="CancelStream" disabled="@StopDisabled" title="停止">
                                &#9632;
                            </button>
                            <button class="icon-btn primary" @onclick="SendAsync" disabled="@SendDisabled" title="送信">
                                &#10148;
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        @if (ShowActivityPanel)
        {
            <div class="activity-scrim" @onclick="CloseActivityPanel"></div>
        }

        <aside class="activity-panel glass-card @(ShowActivityPanel ? "open" : string.Empty)">
            <div class="activity-header">
                <div>
                    <div class="activity-title">アクティビティ</div>
                    <div class="activity-sub">@GetActivitySummary()</div>
                </div>
                <button class="icon-btn tertiary activity-close" @onclick="CloseActivityPanel" aria-label="閉じる">✕</button>
            </div>
            <div class="activity-body">
                @RenderActivityList()
            </div>
        </aside>
    </div>

    @if (LightboxAttachment is not null)
    {
        <div class="lightbox" @onclick="CloseLightbox">
            <div class="lightbox-content" @onclick:stopPropagation="true">
                <button class="icon-btn tertiary lightbox-close" @onclick="CloseLightbox" aria-label="閉じる">✕</button>
                <img src="@LightboxAttachment.MediumBase64" alt="@LightboxAttachment.FileName" />
                <div class="lightbox-meta">
                    <div class="name">@LightboxAttachment.FileName</div>
                    <div class="size">@FormatSize(LightboxAttachment.Size)</div>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [CascadingParameter] public Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;
    [SupplyParameterFromQuery(Name = "c")] public string? ConversationIdParam { get; set; }

    private const int ComposerMaxLines = 6;
    private const long AttachmentMaxBytes = 10 * 1024 * 1024;
    private const int AttachmentMaxCount = 5;

    private readonly List<ChatMessage> Messages = new();
    private readonly List<TurnActivity> TurnActivities = new();
    private readonly List<ImageAttachment> ComposerAttachments = new();
    private string Input = string.Empty;
    private string? Status;
    private bool IsSending;
    private bool IsUploadingAttachment;
    private string? ConversationId;
    private string? _activeAgentNumber;
    private CancellationTokenSource? _cts;
    private ElementReference MessageList;
    private ElementReference ComposerInput;
    private IDisposable? _llmOptionsSubscription;
    private DotNetObjectReference<Home>? _dotNetRef;
    private UserContext? _user;
    private string? _loadedConversationId;
    private ChatMessage? _latestAssistant;
    private int? _streamingAssistantIndex;
    private readonly Dictionary<string, StringBuilder> _assistantStreamBuffers = new();
    private bool ShowActivityPanel;
    private int? SelectedTurnNumber;
    private int? _composerHandlerId;
    private int? _composerAutoResizeHandlerId;
    private int? _composerPasteHandlerId;
    private bool HasActivity => TurnActivities.Any(t => t.Items.Any() || t.IsLive) || IsSending;
    private readonly Dictionary<int, FeedbackRating> FeedbackRatings = new();
    private readonly HashSet<int> FeedbackSubmitting = new();
    private int? FeedbackCommentTarget;
    private string FeedbackCommentInput = string.Empty;
    private static readonly TimeSpan ActivityPulseWindow = TimeSpan.FromSeconds(1.5);
    private ImageAttachment? LightboxAttachment;

    private bool SendDisabled => IsSending
        || IsUploadingAttachment
        || !HasAgentSelected
        || (string.IsNullOrWhiteSpace(Input) && !ComposerAttachments.Any());
    private bool StopDisabled => !IsSending;
    private bool HasAgentSelected => !string.IsNullOrWhiteSpace(AgentState.SelectedAgentNumber);

    private string RenderMarkdown(string markdown)
    {
        if (MarkdownRenderer is null)
        {
            return HtmlEncoder.Default.Encode(markdown ?? string.Empty);
        }

        return MarkdownRenderer.Render(markdown);
    }

    protected override async Task OnInitializedAsync()
    {
        _user = await ResolveUserAsync();

        await AgentState.LoadAsync(_user.UserId);
        _activeAgentNumber = AgentState.SelectedAgentNumber;
        await HistoryState.LoadAsync(_user.UserId, AgentState.SelectedAgentNumber);
        if (!HasAgentSelected)
        {
            Status = "装置エージェントを選択してください";
        }

        _llmOptionsSubscription = LlmOptions.OnChange(_ => InvokeAsync(StateHasChanged));
        AgentState.Changed += OnAgentStateChanged;
        PlcConnectionState.SetAgent(AgentState.SelectedAgentNumber);
        PlcConnectionState.Changed += OnPlcConnectionStateChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await RegisterComposerHandlersAsync();
        await ResizeComposerAsync();
    }

    private async Task RegisterComposerHandlersAsync()
    {
        if (JS is null)
        {
            return;
        }

        if (!_composerHandlerId.HasValue)
        {
            try
            {
                _composerHandlerId = await JS.InvokeAsync<int>("mochaComposer.attachEnterHandler", ComposerInput);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "Enterキー送信ハンドラの初期化に失敗しました");
            }
        }

        if (!_composerAutoResizeHandlerId.HasValue)
        {
            try
            {
                _composerAutoResizeHandlerId = await JS.InvokeAsync<int>("mochaComposer.attachAutoResize", ComposerInput, ComposerMaxLines);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "自動リサイズの初期化に失敗しました");
            }
        }

        if (!_composerPasteHandlerId.HasValue)
        {
            try
            {
                _dotNetRef ??= DotNetObjectReference.Create(this);
                _composerPasteHandlerId = await JS.InvokeAsync<int>("mochaComposer.attachPasteHandler", ComposerInput, _dotNetRef);
            }
            catch (Exception ex)
            {
                Logger.LogWarning(ex, "ペーストハンドラの初期化に失敗しました");
            }
        }
    }

    private async Task ResizeComposerAsync()
    {
        if (JS is null)
        {
            return;
        }

        try
        {
            await JS.InvokeVoidAsync("mochaComposer.resize", ComposerInput, ComposerMaxLines);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "自動リサイズの再計算に失敗しました");
        }
    }

    private async Task HandleFileSelected(InputFileChangeEventArgs e)
    {
        if (AttachmentService is null)
        {
            return;
        }

        var files = e.GetMultipleFiles();
        foreach (var file in files)
        {
            if (ComposerAttachments.Count >= AttachmentMaxCount)
            {
                Status = $"画像は最大{AttachmentMaxCount}枚までです";
                break;
            }

            if (file.Size > AttachmentMaxBytes)
            {
                Status = "画像サイズが上限を超えています（最大10MB）";
                continue;
            }

            IsUploadingAttachment = true;
            try
            {
                var attachment = await AttachmentService.UploadAsync(file);
                ComposerAttachments.Add(attachment);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "添付の追加に失敗しました");
                Status = ex.Message;
            }
            finally
            {
                IsUploadingAttachment = false;
            }
        }

        await InvokeAsync(StateHasChanged);
    }

    [JSInvokable]
    public async Task OnImagePastedAsync(string fileName, string contentType, string dataUrl)
    {
        if (AttachmentService is null)
        {
            return;
        }

        if (ComposerAttachments.Count >= AttachmentMaxCount)
        {
            Status = $"画像は最大{AttachmentMaxCount}枚までです";
            await InvokeAsync(StateHasChanged);
            return;
        }

        try
        {
            var (bytes, actualContentType) = DecodeDataUrl(dataUrl, contentType);
            IsUploadingAttachment = true;
            var safeName = string.IsNullOrWhiteSpace(fileName) ? "pasted-image.png" : fileName;
            var attachment = await AttachmentService.UploadAsync(safeName, actualContentType, bytes);
            ComposerAttachments.Add(attachment);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ペースト画像の追加に失敗しました");
            Status = ex.Message;
        }
        finally
        {
            IsUploadingAttachment = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private static (byte[] Data, string ContentType) DecodeDataUrl(string dataUrl, string hintedContentType)
    {
        if (string.IsNullOrWhiteSpace(dataUrl))
        {
            throw new InvalidOperationException("画像が取得できませんでした");
        }

        var commaIndex = dataUrl.IndexOf(',');
        if (commaIndex < 0)
        {
            throw new InvalidOperationException("不正な画像データです");
        }

        var header = dataUrl[..commaIndex];
        var actualContentType = hintedContentType;
        if (header.StartsWith("data:", StringComparison.OrdinalIgnoreCase))
        {
            var end = header.IndexOf(';');
            if (end > 5)
            {
                actualContentType = header[5..end];
            }
        }
        actualContentType = string.IsNullOrWhiteSpace(actualContentType) ? "image/png" : actualContentType;

        var base64 = dataUrl[(commaIndex + 1)..];
        return (Convert.FromBase64String(base64), actualContentType);
    }

    private async Task RemoveAttachmentAsync(string attachmentId)
    {
        if (AttachmentService is null)
        {
            return;
        }

        var target = ComposerAttachments.FirstOrDefault(a => a.Id == attachmentId);
        if (target is null)
        {
            return;
        }

        ComposerAttachments.Remove(target);
        await AttachmentService.DeleteAsync(attachmentId);
        await InvokeAsync(StateHasChanged);
    }

    private static string FormatSize(long bytes)
    {
        const double kb = 1024d;
        const double mb = kb * 1024d;
        if (bytes >= mb)
        {
            return $"{bytes / mb:0.0} MB";
        }

        if (bytes >= kb)
        {
            return $"{bytes / kb:0.0} KB";
        }

        return $"{bytes} B";
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.Equals(ConversationIdParam, _loadedConversationId, StringComparison.Ordinal))
        {
            _loadedConversationId = ConversationIdParam;
            if (string.IsNullOrWhiteSpace(ConversationIdParam))
            {
                ResetConversation();
            }
            else
            {
                await LoadConversationAsync(ConversationIdParam);
            }
        }

        if (!Messages.Any())
        {
            SeedInitialMessage();
        }
    }

    private async Task SendAsync()
    {
        if (string.IsNullOrWhiteSpace(Input) && !ComposerAttachments.Any())
        {
            return;
        }

        var agentNumber = AgentState.SelectedAgentNumber;
        if (string.IsNullOrWhiteSpace(agentNumber))
        {
            Status = "装置エージェントを選択してください";
            return;
        }

        CancelStream();
        _cts = new CancellationTokenSource();

        var text = Input.Trim();
        var attachmentsToSend = ComposerAttachments.ToList();
        Input = string.Empty;
        ComposerAttachments.Clear();
        IsSending = true;
        Status = null;

        if (Messages.Count == 1
            && Messages[0].Role == ChatRole.Assistant
            && string.Equals(Messages[0].Content, "こんにちは、何をお手伝いしましょうか？", StringComparison.Ordinal))
        {
            Messages.Clear();
            TurnActivities.Clear();
            SelectedTurnNumber = null;
            _latestAssistant = null;
        }

        ConversationId ??= Guid.NewGuid().ToString("N");
        var sendingConversationId = ConversationId;
        NavigateToConversationIfNeeded(sendingConversationId);
        _assistantStreamBuffers[sendingConversationId] = new StringBuilder();
        _activeAgentNumber = agentNumber;
        var user = _user ?? new UserContext("anonymous", "Anonymous");

        var userMessage = new ChatMessage(ChatRole.User, text, attachmentsToSend);
        Messages.Add(userMessage);
        StartNewTurn(TurnActivities.Count);
        _latestAssistant = null;
        _streamingAssistantIndex = null;
        ShowActivityPanel = false;
        await InvokeAsync(StateHasChanged);

        try
        {
            await foreach (var ev in Orchestrator.HandleUserMessageAsync(user, ConversationId, text, agentNumber, attachmentsToSend, _cts.Token))
            {
                var isStale = !string.Equals(ConversationId, sendingConversationId, StringComparison.Ordinal);

                switch (ev.Type)
                {
                    case ChatStreamEventType.Message when ev.Message is not null:
                        if (!isStale)
                        {
                            HandleAssistantMessageChunk(ev.Message, sendingConversationId);
                        }
                        else if (ev.Message.Role == ChatRole.Assistant)
                        {
                            AppendToStreamBuffer(ev.Message.Content, sendingConversationId);
                        }
                        break;
                    case ChatStreamEventType.ActionRequest when ev.ActionRequest is not null:
                        await HistoryState.UpsertAsync(user.UserId, sendingConversationId, text, agentNumber, preserveExistingTitle: true);
                        if (!isStale)
                        {
                            ConversationId ??= ev.ActionRequest.ConversationId;
                            RecordActivity(ActivityKind.Action, $"ツール要求: {ev.ActionRequest.ActionName}", SafeSerialize(ev.ActionRequest.Payload));
                        }
                        break;
                    case ChatStreamEventType.ToolResult when ev.ActionResult is not null:
                        var payloadJson = SafeSerialize(ev.ActionResult.Payload);
                        if (!isStale)
                        {
                            ConversationId ??= ev.ActionResult.ConversationId;
                            RecordActivity(ActivityKind.ToolResult, $"ツール結果: {ev.ActionResult.ActionName}", payloadJson);
                        }
                        break;
                    case ChatStreamEventType.Completed:
                        if (!isStale)
                        {
                            Status = null;
                            MarkActiveTurnCompleted();
                            if (_latestAssistant is not null)
                            {
                                RecordActivity(ActivityKind.Assistant, $"アシスタント: {TrimForPreview(_latestAssistant.Content)}", _latestAssistant.Content);
                            }
                            _streamingAssistantIndex = null;
                        }
                        _assistantStreamBuffers.Remove(sendingConversationId);
                        break;
                    case ChatStreamEventType.Error:
                        if (!isStale)
                        {
                            Status = ev.Error;
                            RecordActivity(ActivityKind.Error, "エラー", ev.Error);
                        }
                        break;
                }

                if (!isStale)
                {
                    await ScrollToBottom();
                    await InvokeAsync(StateHasChanged);
                }
            }
        }
        catch (OperationCanceledException)
        {
            Status = "キャンセルしました";
        }
        finally
        {
            var isStale = !string.Equals(ConversationId, sendingConversationId, StringComparison.Ordinal);
            if (!isStale)
            {
                MarkActiveTurnCompleted();
                IsSending = false;
                _streamingAssistantIndex = null;
                _assistantStreamBuffers.Remove(sendingConversationId);
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private static string GetBubbleClass(ChatRole role)
    {
        return role switch
        {
            ChatRole.User => "bubble from-user",
            ChatRole.Assistant => "bubble from-assistant",
            ChatRole.Tool => "bubble from-tool",
            _ => "bubble"
        };
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key != "Enter")
        {
            return;
        }

        if (e.ShiftKey)
        {
            return;
        }

        await SendAsync();
    }

    private void OnAgentStateChanged()
    {
        _ = InvokeAsync(async () =>
        {
            var selected = AgentState.SelectedAgentNumber;
            if (!string.Equals(_activeAgentNumber, selected, StringComparison.Ordinal))
            {
                ResetConversation();
                _activeAgentNumber = selected;
            }
            PlcConnectionState.SetAgent(selected);

            if (string.IsNullOrWhiteSpace(selected))
            {
                Status = "装置エージェントを選択してください";
            }

            StateHasChanged();
        });
    }

    private void OnPlcConnectionStateChanged()
    {
        _ = InvokeAsync(StateHasChanged);
    }

    private void CancelStream()
    {
        if (_cts is { IsCancellationRequested: false })
        {
            _cts.Cancel();
        }

        _assistantStreamBuffers.Clear();
        _streamingAssistantIndex = null;
    }

    private void OpenLightbox(ImageAttachment attachment)
    {
        LightboxAttachment = attachment;
    }

    private void CloseLightbox()
    {
        LightboxAttachment = null;
    }

    private void SeedInitialMessage()
    {
        Messages.Add(new ChatMessage(ChatRole.Assistant, "こんにちは、何をお手伝いしましょうか？"));
    }

    private void ResetConversation()
    {
        ConversationId = null;
        _activeAgentNumber = AgentState.SelectedAgentNumber;
        Messages.Clear();
        TurnActivities.Clear();
        Status = null;
        Input = string.Empty;
        ComposerAttachments.Clear();
        ShowActivityPanel = false;
        SelectedTurnNumber = null;
        _latestAssistant = null;
        _streamingAssistantIndex = null;
        FeedbackRatings.Clear();
        FeedbackSubmitting.Clear();
        FeedbackCommentTarget = null;
        FeedbackCommentInput = string.Empty;
        LightboxAttachment = null;
        SeedInitialMessage();
    }

    private async Task LoadConversationAsync(string conversationId)
    {
        ConversationId = conversationId;
        _activeAgentNumber = AgentState.SelectedAgentNumber;
        Messages.Clear();
        TurnActivities.Clear();
        Status = null;
        Input = string.Empty;
        ComposerAttachments.Clear();
        ShowActivityPanel = false;
        SelectedTurnNumber = null;
        _latestAssistant = null;
        _streamingAssistantIndex = null;
        LightboxAttachment = null;

        var user = _user ?? await ResolveUserAsync();
        var historyMessages = await ChatRepository.GetMessagesAsync(user.UserId, conversationId, AgentState.SelectedAgentNumber);
        Messages.AddRange(ChatMessageProjector.KeepUserAndFinalAssistant(historyMessages));
        RebuildActivityFromHistory(historyMessages);

        if (!Messages.Any())
        {
            SeedInitialMessage();
        }

        await LoadFeedbackRatingsAsync();
        await InvokeAsync(StateHasChanged);
    }

    private async Task ScrollToBottom()
    {
        // Placeholder for future JS interop to auto-scroll.
        await Task.CompletedTask;
    }

    private async Task<UserContext> ResolveUserAsync()
    {
        var authState = await AuthenticationStateTask;
        var principal = authState.User;
        var objectId = principal.FindFirst("oid")?.Value
                       ?? principal.FindFirst(ClaimTypes.NameIdentifier)?.Value
                       ?? principal.Identity?.Name
                       ?? "anonymous";
        var displayName = principal.Identity?.Name
                          ?? principal.FindFirst("name")?.Value
                          ?? "ユーザー";
        return new UserContext(objectId, displayName);
    }

    private void RecordActivity(ActivityKind kind, string title, string? detail = null)
    {
        var current = TurnActivities.LastOrDefault();
        if (current is null)
        {
            return;
        }

        current.AddLog(new ActivityLogItem(title, detail, kind, DateTimeOffset.UtcNow));
    }

    private void ToggleActivityPanel()
    {
        if (ShowActivityPanel)
        {
            ShowActivityPanel = false;
            SelectedTurnNumber = null;
            return;
        }

        SelectedTurnNumber = null;
        ShowActivityPanel = true;
    }

    private void OpenActivityPanelForTurn(int turnNumber)
    {
        SelectedTurnNumber = turnNumber;
        ShowActivityPanel = true;
    }

    private void CloseActivityPanel()
    {
        ShowActivityPanel = false;
        SelectedTurnNumber = null;
    }

    private static string GetPillClass(ActivityKind kind) => kind switch
    {
        ActivityKind.Action => "pill-action",
        ActivityKind.ToolResult => "pill-tool",
        ActivityKind.Error => "pill-error",
        _ => "pill-assistant"
    };

    private static string GetPillLabel(ActivityKind kind) => kind switch
    {
        ActivityKind.Action => "Action",
        ActivityKind.ToolResult => "Result",
        ActivityKind.Error => "Error",
        _ => "Thought"
    };

    private static readonly JsonSerializerOptions SerializerOptions = new(JsonSerializerDefaults.Web)
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping
    };

    private static string SafeSerialize(IReadOnlyDictionary<string, object?> payload) =>
        JsonSerializer.Serialize(payload, SerializerOptions);

    private void RebuildActivityFromHistory(IReadOnlyList<ChatMessage> historyMessages)
    {
        TurnActivities.Clear();
        var built = ActivityBuilder.BuildActivities(historyMessages);
        TurnActivities.AddRange(built);
    }

    private void StartNewTurn(int turnNumber)
    {
        TurnActivities.Add(new TurnActivity(turnNumber));
    }

    private TurnActivity? GetTurnActivityForTurn(int turnNumber)
    {
        return TurnActivities.FirstOrDefault(t => t.TurnNumber == turnNumber);
    }

    private TurnActivity? GetCurrentTurn() => TurnActivities.LastOrDefault();

    private void MarkActiveTurnCompleted()
    {
        GetCurrentTurn()?.MarkCompleted();
    }

    private string GetActivitySummary() => ActivityPanelService.GetActivitySummary(GetPanelLogs());

    private string GetChipClass(TurnActivity? activity)
    {
        var classes = new List<string> { "thinking-chip" };
        if (activity is null)
        {
            classes.Add("collapsed");
            return string.Join(" ", classes);
        }

        classes.Add(activity.IsLive ? "live" : activity.IsCompleted ? "completed" : "collapsed");
        if (activity.IsRecentlyUpdated(ActivityPulseWindow, DateTimeOffset.UtcNow))
        {
            classes.Add("pulse");
        }

        return string.Join(" ", classes);
    }

    private string GetChipCountLabel(TurnActivity? activity, bool hasLog)
    {
        if (activity is null)
        {
            return "経過なし";
        }

        var count = activity.Items.Count;
        var label = (hasLog || count > 0) ? $"{count} 件の経過" : "経過なし";
        if (activity.IsLive)
        {
            var status = GetChipStatus(activity);
            var statusText = string.IsNullOrWhiteSpace(status) ? "更新中" : status;
            return $"{label} ({statusText})";
        }

        if (activity.IsCompleted)
        {
            return $"{label} (完了)";
        }

        return label;
    }

    private string GetChipStatus(TurnActivity? activity)
    {
        if (activity is null)
        {
            return "待機中";
        }

        if (activity.IsLive)
        {
            var actionLabel = GetLatestActionLabel(activity);
            var text = !string.IsNullOrWhiteSpace(Status)
                ? Status
                : !string.IsNullOrWhiteSpace(actionLabel)
                    ? actionLabel.Replace("ツール要求:", "ツール実行中:")
                    : "進行中";

            return TruncateLabel(text, 30);
        }

        if (activity.IsCompleted)
        {
            return "完了";
        }

        return "待機中";
    }

    private static string? GetLatestActionLabel(TurnActivity? activity)
    {
        if (activity is null)
        {
            return null;
        }

        var lastAction = activity.Items.LastOrDefault(i => i.Kind == ActivityKind.Action);
        return lastAction?.Title;
    }

    private static string TruncateLabel(string text, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return text;
        }

        return text.Length <= maxLength
            ? text
            : $"{text[..maxLength]}…";
    }

    private RenderFragment RenderActivityList() => builder =>
    {
        var seq = 0;
        var logs = GetPanelLogs().ToList();
        if (logs.Any())
        {
            foreach (var log in logs)
            {
                builder.OpenElement(seq++, "div");
                builder.AddAttribute(seq++, "class", "activity-item");

                builder.OpenElement(seq++, "div");
                builder.AddAttribute(seq++, "class", "activity-meta");
                builder.OpenElement(seq++, "span");
                builder.AddAttribute(seq++, "class", $"pill {GetPillClass(log.Kind)}");
                builder.AddContent(seq++, GetPillLabel(log.Kind));
                builder.CloseElement();
                builder.OpenElement(seq++, "span");
                builder.AddAttribute(seq++, "class", "timestamp");
                builder.AddContent(seq++, log.Timestamp.ToLocalTime().ToString("HH:mm:ss"));
                builder.CloseElement();
                builder.CloseElement();

                builder.OpenElement(seq++, "div");
                builder.AddAttribute(seq++, "class", "activity-title-text");
                builder.AddContent(seq++, log.Title);
                builder.CloseElement();

                if (!string.IsNullOrWhiteSpace(log.Detail))
                {
                    builder.OpenElement(seq++, "div");
                    builder.AddAttribute(seq++, "class", "activity-detail");
                    builder.AddContent(seq++, log.Detail);
                    builder.CloseElement();
                }

                builder.CloseElement();
            }
        }
        else
        {
            builder.OpenElement(seq++, "div");
            builder.AddAttribute(seq++, "class", "activity-empty");
            builder.AddContent(seq++, "思考の途中経過がここに表示されます。");
            builder.CloseElement();
        }
    };

    private IEnumerable<ActivityLogItem> GetPanelLogs() => ActivityPanelService.GetPanelLogs(TurnActivities, SelectedTurnNumber);

    private string GetFeedbackButtonClass(int messageIndex, FeedbackRating rating)
    {
        var classes = new List<string> { "feedback-btn" };
        if (rating == FeedbackRating.Good)
        {
            classes.Add("good");
        }
        else
        {
            classes.Add("bad");
        }

        if (FeedbackRatings.TryGetValue(messageIndex, out var current))
        {
            classes.Add(current == rating ? "selected" : "muted");
        }

        if (FeedbackSubmitting.Contains(messageIndex))
        {
            classes.Add("submitting");
        }

        return string.Join(" ", classes);
    }

    private bool IsFeedbackDisabled(int messageIndex)
    {
        if (string.IsNullOrWhiteSpace(ConversationId))
        {
            return true;
        }

        return FeedbackSubmitting.Contains(messageIndex);
    }

    private bool IsRatedAs(int messageIndex, FeedbackRating rating)
    {
        return FeedbackRatings.TryGetValue(messageIndex, out var existing) && existing == rating;
    }

    internal static bool ShouldShowFeedback(ChatMessage message, int messageIndex, int? streamingAssistantIndex)
    {
        if (message.Role != ChatRole.Assistant)
        {
            return false;
        }

        if (streamingAssistantIndex.HasValue && streamingAssistantIndex.Value == messageIndex)
        {
            return false;
        }

        var isInitialGreeting = messageIndex == 0 && message.Content == "こんにちは、何をお手伝いしましょうか？";
        return !isInitialGreeting;
    }

    private async Task LoadFeedbackRatingsAsync()
    {
        FeedbackRatings.Clear();
        if (string.IsNullOrWhiteSpace(ConversationId))
        {
            return;
        }

        try
        {
            var user = _user ?? await ResolveUserAsync();
            var persistedMessages = await ChatRepository.GetMessagesAsync(user.UserId, ConversationId, AgentState.SelectedAgentNumber);
            var ratings = await FeedbackService.GetRatingsAsync(user.UserId, ConversationId, default);
            var persistedToUi = BuildAssistantIndexMap(persistedMessages);
            if (ratings is not null && ratings.Count > 0)
            {
                foreach (var item in ratings)
                {
                    if (persistedToUi.TryGetValue(item.Key, out var uiIndex))
                    {
                        FeedbackRatings[uiIndex] = item.Value;
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "フィードバックの読み込みに失敗しました");
        }
    }

    private async Task SubmitFeedbackAsync(int messageIndex, FeedbackRating rating, string? comment = null)
    {
        if (IsFeedbackDisabled(messageIndex))
        {
            return;
        }

        if (string.IsNullOrWhiteSpace(ConversationId))
        {
            Status = "会話が確定してからフィードバックできます";
            return;
        }

        FeedbackSubmitting.Add(messageIndex);
        try
        {
            var user = _user ?? await ResolveUserAsync();
            var persistedMessages = await ChatRepository.GetMessagesAsync(user.UserId, ConversationId, AgentState.SelectedAgentNumber);
            var uiToPersisted = BuildAssistantIndexMap(persistedMessages)
                .ToDictionary(kvp => kvp.Value, kvp => kvp.Key);

            if (!uiToPersisted.TryGetValue(messageIndex, out var persistedIndex))
            {
                Logger.LogWarning("対応するメッセージが見つからずフィードバックを送信できません (UI index: {UiIndex})", messageIndex);
                return;
            }

            var alreadySame = FeedbackRatings.TryGetValue(messageIndex, out var existing) && existing == rating;

            await FeedbackService.SubmitAsync(user.UserId, ConversationId, persistedIndex, rating, comment, default);

            if (alreadySame)
            {
                FeedbackRatings.Remove(messageIndex);
            }
            else
            {
                FeedbackRatings[messageIndex] = rating;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "フィードバック送信に失敗しました");
        }
        finally
        {
            FeedbackSubmitting.Remove(messageIndex);
        }
    }

    public void Dispose()
    {
        _llmOptionsSubscription?.Dispose();
        _cts?.Dispose();
        if (_composerHandlerId.HasValue && JS is not null)
        {
            _ = JS.InvokeVoidAsync("mochaComposer.detachEnterHandler", _composerHandlerId.Value);
        }
        if (_composerAutoResizeHandlerId.HasValue && JS is not null)
        {
            _ = JS.InvokeVoidAsync("mochaComposer.detachAutoResize", _composerAutoResizeHandlerId.Value);
        }
        if (_composerPasteHandlerId.HasValue && JS is not null)
        {
            _ = JS.InvokeVoidAsync("mochaComposer.detachPasteHandler", _composerPasteHandlerId.Value);
        }

        AgentState.Changed -= OnAgentStateChanged;
        PlcConnectionState.Changed -= OnPlcConnectionStateChanged;
        _dotNetRef?.Dispose();
    }

    private void AppendAssistantChunk(string content)
    {
        AppendAssistantChunk(content, ConversationId);
    }

    private void HandleAssistantMessageChunk(ChatMessage message, string streamConversationId)
    {
        if (message.Role != ChatRole.Assistant)
        {
            Messages.Add(message);
            return;
        }

        var buffer = AppendToStreamBuffer(message.Content, streamConversationId);
        AppendAssistantChunk(buffer, streamConversationId);
    }

    private string AppendToStreamBuffer(string content, string streamConversationId)
    {
        if (!_assistantStreamBuffers.TryGetValue(streamConversationId, out var buffer))
        {
            buffer = new StringBuilder();
            _assistantStreamBuffers[streamConversationId] = buffer;
        }

        buffer.Append(content);
        return buffer.ToString();
    }

    private void AppendAssistantChunk(string bufferedContent, string? streamConversationId)
    {
        if (_streamingAssistantIndex is null)
        {
            var message = new ChatMessage(ChatRole.Assistant, bufferedContent);
            Messages.Add(message);
            _streamingAssistantIndex = Messages.Count - 1;
        }
        else
        {
            var index = _streamingAssistantIndex.Value;
            var current = Messages[index];
            Messages[index] = current with { Content = bufferedContent };
        }

        _latestAssistant = _streamingAssistantIndex is int idx ? Messages[idx] : _latestAssistant;
        if (!string.IsNullOrWhiteSpace(streamConversationId))
        {
            _assistantStreamBuffers[streamConversationId] = new StringBuilder(bufferedContent);
        }
    }

    private void NavigateToConversationIfNeeded(string? conversationId)
    {
        if (string.IsNullOrWhiteSpace(conversationId) || NavigationManager is null)
        {
            return;
        }

        _loadedConversationId = conversationId;
        var target = NavigationManager.GetUriWithQueryParameter("c", conversationId);
        if (!string.Equals(target, NavigationManager.Uri, StringComparison.Ordinal))
        {
            NavigationManager.NavigateTo(target, replace: true);
        }
    }

    private Dictionary<int, int> BuildAssistantIndexMap(IReadOnlyList<ChatMessage> persistedMessages)
    {
        var map = new Dictionary<int, int>();

        var uiAssistants = new List<(int Order, int Index)>();
        var uiOrder = 0;
        for (var i = 0; i < Messages.Count; i++)
        {
            var msg = Messages[i];
            if (!ShouldShowFeedback(msg, i, _streamingAssistantIndex))
            {
                continue;
            }

            uiAssistants.Add((uiOrder, i));
            uiOrder++;
        }

        var persistedAssistants = new List<(int Order, int Index)>();
        var persistedOrder = 0;
        for (var i = 0; i < persistedMessages.Count; i++)
        {
            if (persistedMessages[i].Role == ChatRole.Assistant)
            {
                persistedAssistants.Add((persistedOrder, i));
                persistedOrder++;
            }
        }

        var count = Math.Min(uiAssistants.Count, persistedAssistants.Count);
        for (var i = 0; i < count; i++)
        {
            var persistedIndex = persistedAssistants[i].Index;
            var uiIndex = uiAssistants[i].Index;
            map[persistedIndex] = uiIndex;
        }

        return map;
    }

}
