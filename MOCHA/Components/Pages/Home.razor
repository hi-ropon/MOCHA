@page "/"
@attribute [Authorize]
@using System.Security.Claims
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.Extensions.Options
@using MOCHA.Models.Chat
@using MOCHA.Services.Copilot
@using MOCHA.Services.Plc
@inject MOCHA.Services.Chat.IChatRepository ChatRepository
@inject MOCHA.Services.Chat.IChatOrchestrator Orchestrator
@inject MOCHA.Services.Chat.ConversationHistoryState HistoryState
@inject IOptionsMonitor<CopilotStudioOptions> CopilotOptions
@inject IOptionsMonitor<PlcGatewayOptions> PlcOptions
@implements IDisposable

<PageTitle>Chat</PageTitle>

<div class="chat-shell">
    @if (IsDebug)
    {
        <header class="chat-header glass-card">
            <div>
                <div class="env-badge">DEV</div>
                <div class="status-line">
                    <span class="@CopilotDotClass"></span> @CopilotStatusLabel
                    <span class="@GatewayDotClass"></span> @GatewayStatusLabel
                </div>
            </div>
            <div class="actions">
                <button class="btn btn-sm btn-outline-light" @onclick="ResetConversation">Reset</button>
            </div>
        </header>
    }

    <div class="chat-body">
        <main class="chat-main glass-card">
            <div class="messages" @ref="MessageList">
                @foreach (var message in Messages)
                {
                    <div class="@GetBubbleClass(message.Role)">
                        <div class="content">@message.Content</div>
                    </div>
                }

                @if (!string.IsNullOrEmpty(Status))
                {
                    <div class="status-line">@Status</div>
                }
            </div>

                <div class="composer">
                    <div class="composer-inner">
                        <textarea class="chat-input" placeholder="メッセージを入力 (Ctrl+Enter で送信)"
                                  @bind="Input"
                                  @bind:event="oninput"
                                  @onkeydown="HandleKeyDown"
                                  rows="1"></textarea>
                        <div class="input-actions">
                            <button class="icon-btn secondary" @onclick="CancelStream" disabled="@StopDisabled" title="停止">
                                &#9632;
                            </button>
                        <button class="icon-btn primary" @onclick="SendAsync" disabled="@SendDisabled" title="送信">
                            &#10148;
                        </button>
                    </div>
                </div>
            </div>
        </main>
    </div>
</div>

@code {
    [CascadingParameter] public Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;
    [SupplyParameterFromQuery(Name = "c")] public string? ConversationIdParam { get; set; }

    private readonly List<ChatMessage> Messages = new();
    private string Input = string.Empty;
    private string? Status;
    private bool IsSending;
    private string? ConversationId;
    private CancellationTokenSource? _cts;
    private ElementReference MessageList;
    private IDisposable? _copilotOptionsSubscription;
    private IDisposable? _plcOptionsSubscription;
    private UserContext? _user;
    private string? _loadedConversationId;

    private bool SendDisabled => IsSending || string.IsNullOrWhiteSpace(Input);
    private bool StopDisabled => !IsSending;
    private bool CopilotLive => IsCopilotConfigured(CopilotOptions.CurrentValue);
    private bool GatewayLive => PlcOptions.CurrentValue.Enabled;
    private string CopilotDotClass => $"dot {(CopilotLive ? "dot-on" : "dot-off")}";
    private string GatewayDotClass => $"dot {(GatewayLive ? "dot-on" : "dot-off")}";
    private string CopilotStatusLabel => CopilotLive ? "Copilot" : "Copilot (fake)";
    private string GatewayStatusLabel => GatewayLive ? "Gateway" : "Gateway (fake)";
#if DEBUG
    private const bool IsDebug = true;
#else
    private const bool IsDebug = false;
#endif

    protected override async Task OnInitializedAsync()
    {
        _user = await ResolveUserAsync();

        await HistoryState.LoadAsync(_user.UserId);

        _copilotOptionsSubscription = CopilotOptions.OnChange(_ => InvokeAsync(StateHasChanged));
        _plcOptionsSubscription = PlcOptions.OnChange(_ => InvokeAsync(StateHasChanged));
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.Equals(ConversationIdParam, _loadedConversationId, StringComparison.Ordinal))
        {
            _loadedConversationId = ConversationIdParam;
            if (string.IsNullOrWhiteSpace(ConversationIdParam))
            {
                ResetConversation();
            }
            else
            {
                await LoadConversationAsync(ConversationIdParam);
            }
        }

        if (!Messages.Any())
        {
            SeedInitialMessage();
        }
    }

    private async Task SendAsync()
    {
        if (string.IsNullOrWhiteSpace(Input))
        {
            return;
        }

        CancelStream();
        _cts = new CancellationTokenSource();

        var text = Input.Trim();
        Input = string.Empty;
        IsSending = true;
        Status = null;

        ConversationId ??= Guid.NewGuid().ToString("N");
        var user = _user ?? new UserContext("anonymous", "Anonymous");

        var userMessage = new ChatMessage(ChatRole.User, text);
        Messages.Add(userMessage);
        await InvokeAsync(StateHasChanged);

        try
        {
            await foreach (var ev in Orchestrator.HandleUserMessageAsync(user, ConversationId, text, _cts.Token))
            {
                switch (ev.Type)
                {
                    case ChatStreamEventType.Message when ev.Message is not null:
                        Messages.Add(ev.Message);
                        break;
                    case ChatStreamEventType.ActionRequest when ev.ActionRequest is not null:
                        ConversationId ??= ev.ActionRequest.ConversationId;
                        await HistoryState.UpsertAsync(user.UserId, ConversationId, text);
                        Status = $"ツール実行中: {ev.ActionRequest.ActionName}";
                        break;
                    case ChatStreamEventType.ToolResult when ev.ActionResult is not null:
                        ConversationId ??= ev.ActionResult.ConversationId;
                        var payloadJson = System.Text.Json.JsonSerializer.Serialize(ev.ActionResult.Payload);
                        Messages.Add(new ChatMessage(ChatRole.Tool, $"{ev.ActionResult.ActionName}: {payloadJson}"));
                        Status = null;
                        break;
                    case ChatStreamEventType.Completed:
                        Status = null;
                        break;
                    case ChatStreamEventType.Error:
                        Status = ev.Error;
                        break;
                }

                await ScrollToBottom();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            Status = "キャンセルしました";
        }
        finally
        {
            IsSending = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private static string GetBubbleClass(ChatRole role)
    {
        return role switch
        {
            ChatRole.User => "bubble from-user",
            ChatRole.Assistant => "bubble from-assistant",
            ChatRole.Tool => "bubble from-tool",
            _ => "bubble"
        };
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.CtrlKey && e.Key == "Enter")
        {
            await SendAsync();
        }
    }

    private void CancelStream()
    {
        if (_cts is { IsCancellationRequested: false })
        {
            _cts.Cancel();
        }
    }

    private void SeedInitialMessage()
    {
        Messages.Add(new ChatMessage(ChatRole.Assistant, "こんにちは、何をお手伝いしましょうか？"));
    }

    private void ResetConversation()
    {
        CancelStream();
        ConversationId = null;
        Messages.Clear();
        Status = null;
        Input = string.Empty;
        SeedInitialMessage();
    }

    private async Task LoadConversationAsync(string conversationId)
    {
        CancelStream();
        ConversationId = conversationId;
        Messages.Clear();
        Status = null;
        Input = string.Empty;

        var user = _user ?? await ResolveUserAsync();
        var historyMessages = await ChatRepository.GetMessagesAsync(user.UserId, conversationId);
        Messages.AddRange(historyMessages);

        if (!Messages.Any())
        {
            SeedInitialMessage();
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task ScrollToBottom()
    {
        // Placeholder for future JS interop to auto-scroll.
        await Task.CompletedTask;
    }

    private static bool IsCopilotConfigured(CopilotStudioOptions options)
    {
        return options.Enabled &&
               (!string.IsNullOrWhiteSpace(options.DirectConnectUrl) ||
                !string.IsNullOrWhiteSpace(options.EnvironmentId)) &&
               !string.IsNullOrWhiteSpace(options.SchemaName);
    }

    private async Task<UserContext> ResolveUserAsync()
    {
        var authState = await AuthenticationStateTask;
        var principal = authState.User;
        var objectId = principal.FindFirst("oid")?.Value
                       ?? principal.FindFirst(ClaimTypes.NameIdentifier)?.Value
                       ?? principal.Identity?.Name
                       ?? "anonymous";
        var displayName = principal.Identity?.Name
                          ?? principal.FindFirst("name")?.Value
                          ?? "ユーザー";
        return new UserContext(objectId, displayName);
    }

    public void Dispose()
    {
        _copilotOptionsSubscription?.Dispose();
        _plcOptionsSubscription?.Dispose();
        _cts?.Dispose();
    }

}
