@page "/"
@attribute [Authorize]
@using System.Security.Claims
@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.Extensions.Options
@using MOCHA.Models.Chat
@using MOCHA.Services.Copilot
@using MOCHA.Services.Plc
@inject MOCHA.Services.Chat.IChatRepository ChatRepository
@inject MOCHA.Services.Chat.IChatOrchestrator Orchestrator
@inject MOCHA.Services.Chat.ConversationHistoryState HistoryState
@inject MOCHA.Services.Agents.DeviceAgentState AgentState
@inject IOptionsMonitor<CopilotStudioOptions> CopilotOptions
@inject IOptionsMonitor<PlcGatewayOptions> PlcOptions
@implements IDisposable

<PageTitle>M.O.C.H.A.</PageTitle>

<div class="chat-shell">
    @if (IsDebug)
    {
        <header class="chat-header glass-card">
            <div>
                <div class="env-badge">DEV</div>
                <div class="status-line">
                    <span class="@CopilotDotClass"></span> @CopilotStatusLabel
                    <span class="@GatewayDotClass"></span> @GatewayStatusLabel
                </div>
            </div>
            <div class="actions">
                <button class="btn btn-sm btn-outline-light" @onclick="ResetConversation">Reset</button>
            </div>
        </header>
    }

    <div class="chat-body">
        <main class="chat-main glass-card">
            <div class="messages" @ref="MessageList">
                @foreach (var message in Messages)
                {
                    <div class="@GetBubbleClass(message.Role)">
                        <div class="content">@message.Content</div>
                    </div>
                }

                @if (HasActivity)
                {
                    <div class="thinking-chip @(IsSending ? "live" : "collapsed")" @onclick="OpenActivityPanel">
                        <div class="chip-header">
                            <span class="chip-title">思考時間</span>
                            <span class="chip-count">@(ActivityLog.Any() ? $"{ActivityLog.Count} 件の経過" : "処理中…")</span>
                        </div>
                        <div class="chip-body">
                            @if (IsSending)
                            {
                                <div class="chip-stream">
                                    @if (ActivityLog.Any())
                                    {
                                        @foreach (var log in TakeLatestActivity(2))
                                        {
                                            <div class="chip-line">@log.Title</div>
                                        }
                                    }
                                    <div class="chip-line muted">...考え中</div>
                                </div>
                            }
                            else
                            {
                                <div class="chip-line muted">クリックでアクティビティを開く</div>
                            }
                        </div>
                    </div>
                }

                @if (!string.IsNullOrEmpty(Status))
                {
                    <div class="status-line">@Status</div>
                }
            </div>

            <div class="composer">
                <div class="composer-inner">
                    <textarea class="chat-input" placeholder="メッセージを入力 (Ctrl+Enter で送信)"
                              @bind="Input"
                              @bind:event="oninput"
                              @onkeydown="HandleKeyDown"
                              rows="1"></textarea>
                    <div class="input-actions">
                        <button class="icon-btn secondary" @onclick="CancelStream" disabled="@StopDisabled" title="停止">
                            &#9632;
                        </button>
                        <button class="icon-btn primary" @onclick="SendAsync" disabled="@SendDisabled" title="送信">
                            &#10148;
                        </button>
                        <button class="icon-btn tertiary" @onclick="ToggleActivityPanel" title="アクティビティ">
                            ☰
                        </button>
                    </div>
                </div>
            </div>
        </main>

        @if (ShowActivityPanel)
        {
            <div class="activity-scrim" @onclick="CloseActivityPanel"></div>
        }

        <aside class="activity-panel glass-card @(ShowActivityPanel ? "open" : string.Empty)">
            <div class="activity-header">
                <div>
                    <div class="activity-title">アクティビティ</div>
                    <div class="activity-sub">
                        @if (ActivityLog.Any())
                        {
                            @($"{ActivityLog.Count} 件の途中経過")
                        }
                        else
                        {
                            <span>まだありません</span>
                        }
                    </div>
                </div>
                <button class="icon-btn tertiary" @onclick="CloseActivityPanel" aria-label="閉じる">✕</button>
            </div>
            <div class="activity-body">
                @if (ActivityLog.Any())
                {
                    @foreach (var log in ActivityLog)
                    {
                        <div class="activity-item">
                            <div class="activity-meta">
                                <span class="pill @GetPillClass(log.Kind)">@GetPillLabel(log.Kind)</span>
                                <span class="timestamp">@log.Timestamp.ToLocalTime().ToString("HH:mm:ss")</span>
                            </div>
                            <div class="activity-title-text">@log.Title</div>
                            @if (!string.IsNullOrWhiteSpace(log.Detail))
                            {
                                <div class="activity-detail">@log.Detail</div>
                            }
                        </div>
                    }
                }
                else
                {
                    <div class="activity-empty">思考の途中経過がここに表示されます。</div>
                }
            </div>
        </aside>
    </div>
</div>

@code {
    [CascadingParameter] public Task<AuthenticationState> AuthenticationStateTask { get; set; } = default!;
    [SupplyParameterFromQuery(Name = "c")] public string? ConversationIdParam { get; set; }

    private readonly List<ChatMessage> Messages = new();
    private readonly List<ActivityLogItem> ActivityLog = new();
    private string Input = string.Empty;
    private string? Status;
    private bool IsSending;
    private string? ConversationId;
    private string? _activeAgentNumber;
    private CancellationTokenSource? _cts;
    private ElementReference MessageList;
    private IDisposable? _copilotOptionsSubscription;
    private IDisposable? _plcOptionsSubscription;
    private UserContext? _user;
    private string? _loadedConversationId;
    private ChatMessage? _latestAssistant;
    private bool ShowActivityPanel;
    private bool HasActivity => ActivityLog.Any() || IsSending;

    private bool SendDisabled => IsSending || string.IsNullOrWhiteSpace(Input) || !HasAgentSelected;
    private bool StopDisabled => !IsSending;
    private bool HasAgentSelected => !string.IsNullOrWhiteSpace(AgentState.SelectedAgentNumber);
    private bool CopilotLive => IsCopilotConfigured(CopilotOptions.CurrentValue);
    private bool GatewayLive => PlcOptions.CurrentValue.Enabled;
    private string CopilotDotClass => $"dot {(CopilotLive ? "dot-on" : "dot-off")}";
    private string GatewayDotClass => $"dot {(GatewayLive ? "dot-on" : "dot-off")}";
    private string CopilotStatusLabel => CopilotLive ? "Copilot" : "Copilot (fake)";
    private string GatewayStatusLabel => GatewayLive ? "Gateway" : "Gateway (fake)";
#if DEBUG
    private const bool IsDebug = true;
#else
    private const bool IsDebug = false;
#endif

    protected override async Task OnInitializedAsync()
    {
        _user = await ResolveUserAsync();

        await AgentState.LoadAsync(_user.UserId);
        _activeAgentNumber = AgentState.SelectedAgentNumber;
        await HistoryState.LoadAsync(_user.UserId, AgentState.SelectedAgentNumber);
        if (!HasAgentSelected)
        {
            Status = "装置エージェントを選択してください";
        }

        _copilotOptionsSubscription = CopilotOptions.OnChange(_ => InvokeAsync(StateHasChanged));
        _plcOptionsSubscription = PlcOptions.OnChange(_ => InvokeAsync(StateHasChanged));
        AgentState.Changed += OnAgentStateChanged;
    }

    protected override async Task OnParametersSetAsync()
    {
        if (!string.Equals(ConversationIdParam, _loadedConversationId, StringComparison.Ordinal))
        {
            _loadedConversationId = ConversationIdParam;
            if (string.IsNullOrWhiteSpace(ConversationIdParam))
            {
                ResetConversation();
            }
            else
            {
                await LoadConversationAsync(ConversationIdParam);
            }
        }

        if (!Messages.Any())
        {
            SeedInitialMessage();
        }
    }

    private async Task SendAsync()
    {
        if (string.IsNullOrWhiteSpace(Input))
        {
            return;
        }

        var agentNumber = AgentState.SelectedAgentNumber;
        if (string.IsNullOrWhiteSpace(agentNumber))
        {
            Status = "装置エージェントを選択してください";
            return;
        }

        CancelStream();
        _cts = new CancellationTokenSource();

        var text = Input.Trim();
        Input = string.Empty;
        IsSending = true;
        Status = null;

        ConversationId ??= Guid.NewGuid().ToString("N");
        _activeAgentNumber = agentNumber;
        var user = _user ?? new UserContext("anonymous", "Anonymous");

        var userMessage = new ChatMessage(ChatRole.User, text);
        Messages.Add(userMessage);
        ActivityLog.Clear();
        _latestAssistant = null;
        ShowActivityPanel = false;
        await InvokeAsync(StateHasChanged);

        try
        {
            await foreach (var ev in Orchestrator.HandleUserMessageAsync(user, ConversationId, text, agentNumber, _cts.Token))
            {
                switch (ev.Type)
                {
                    case ChatStreamEventType.Message when ev.Message is not null:
                        _latestAssistant = ev.Message;
                        RecordActivity(ActivityKind.Assistant, $"アシスタント: {TrimForPreview(ev.Message.Content)}", ev.Message.Content);
                        break;
                    case ChatStreamEventType.ActionRequest when ev.ActionRequest is not null:
                        ConversationId ??= ev.ActionRequest.ConversationId;
                        await HistoryState.UpsertAsync(user.UserId, ConversationId, text, agentNumber);
                        Status = $"ツール実行中: {ev.ActionRequest.ActionName}";
                        RecordActivity(ActivityKind.Action, $"ツール要求: {ev.ActionRequest.ActionName}", SafeSerialize(ev.ActionRequest.Payload));
                        break;
                    case ChatStreamEventType.ToolResult when ev.ActionResult is not null:
                        ConversationId ??= ev.ActionResult.ConversationId;
                        var payloadJson = SafeSerialize(ev.ActionResult.Payload);
                        RecordActivity(ActivityKind.ToolResult, $"ツール結果: {ev.ActionResult.ActionName}", payloadJson);
                        break;
                    case ChatStreamEventType.Completed:
                        Status = null;
                        if (_latestAssistant is not null)
                        {
                            Messages.Add(_latestAssistant);
                        }
                        break;
                    case ChatStreamEventType.Error:
                        Status = ev.Error;
                        RecordActivity(ActivityKind.Error, "エラー", ev.Error);
                        break;
                }

                await ScrollToBottom();
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            Status = "キャンセルしました";
        }
        finally
        {
            IsSending = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private static string GetBubbleClass(ChatRole role)
    {
        return role switch
        {
            ChatRole.User => "bubble from-user",
            ChatRole.Assistant => "bubble from-assistant",
            ChatRole.Tool => "bubble from-tool",
            _ => "bubble"
        };
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.CtrlKey && e.Key == "Enter")
        {
            await SendAsync();
        }
    }

    private void OnAgentStateChanged()
    {
        _ = InvokeAsync(async () =>
        {
            var selected = AgentState.SelectedAgentNumber;
            if (!string.Equals(_activeAgentNumber, selected, StringComparison.Ordinal))
            {
                ResetConversation();
                _activeAgentNumber = selected;
            }

            if (string.IsNullOrWhiteSpace(selected))
            {
                Status = "装置エージェントを選択してください";
            }

            StateHasChanged();
        });
    }

    private void CancelStream()
    {
        if (_cts is { IsCancellationRequested: false })
        {
            _cts.Cancel();
        }
    }

    private void SeedInitialMessage()
    {
        Messages.Add(new ChatMessage(ChatRole.Assistant, "こんにちは、何をお手伝いしましょうか？"));
    }

    private void ResetConversation()
    {
        CancelStream();
        ConversationId = null;
        _activeAgentNumber = AgentState.SelectedAgentNumber;
        Messages.Clear();
        ActivityLog.Clear();
        Status = null;
        Input = string.Empty;
        ShowActivityPanel = false;
        _latestAssistant = null;
        SeedInitialMessage();
    }

    private async Task LoadConversationAsync(string conversationId)
    {
        CancelStream();
        ConversationId = conversationId;
        _activeAgentNumber = AgentState.SelectedAgentNumber;
        Messages.Clear();
        ActivityLog.Clear();
        Status = null;
        Input = string.Empty;
        ShowActivityPanel = false;
        _latestAssistant = null;

        var user = _user ?? await ResolveUserAsync();
        var historyMessages = await ChatRepository.GetMessagesAsync(user.UserId, conversationId, AgentState.SelectedAgentNumber);
        Messages.AddRange(ChatMessageProjector.KeepUserAndFinalAssistant(historyMessages));
        RebuildActivityFromHistory(historyMessages);

        if (!Messages.Any())
        {
            SeedInitialMessage();
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task ScrollToBottom()
    {
        // Placeholder for future JS interop to auto-scroll.
        await Task.CompletedTask;
    }

    private static bool IsCopilotConfigured(CopilotStudioOptions options)
    {
        return options.Enabled &&
               (!string.IsNullOrWhiteSpace(options.DirectConnectUrl) ||
                !string.IsNullOrWhiteSpace(options.EnvironmentId)) &&
               !string.IsNullOrWhiteSpace(options.SchemaName);
    }

    private async Task<UserContext> ResolveUserAsync()
    {
        var authState = await AuthenticationStateTask;
        var principal = authState.User;
        var objectId = principal.FindFirst("oid")?.Value
                       ?? principal.FindFirst(ClaimTypes.NameIdentifier)?.Value
                       ?? principal.Identity?.Name
                       ?? "anonymous";
        var displayName = principal.Identity?.Name
                          ?? principal.FindFirst("name")?.Value
                          ?? "ユーザー";
        return new UserContext(objectId, displayName);
    }

    private void RecordActivity(ActivityKind kind, string title, string? detail = null)
    {
        ActivityLog.Add(new ActivityLogItem(title, detail, kind, DateTimeOffset.UtcNow));
    }

    private IEnumerable<ActivityLogItem> TakeLatestActivity(int count) => ActivityLog.TakeLast(count);

    private void ToggleActivityPanel() => ShowActivityPanel = !ShowActivityPanel;

    private void OpenActivityPanel() => ShowActivityPanel = true;

    private void CloseActivityPanel() => ShowActivityPanel = false;

    private static string GetPillClass(ActivityKind kind) => kind switch
    {
        ActivityKind.Action => "pill-action",
        ActivityKind.ToolResult => "pill-tool",
        ActivityKind.Error => "pill-error",
        _ => "pill-assistant"
    };

    private static string GetPillLabel(ActivityKind kind) => kind switch
    {
        ActivityKind.Action => "Action",
        ActivityKind.ToolResult => "Result",
        ActivityKind.Error => "Error",
        _ => "Thought"
    };

    private static string SafeSerialize(IReadOnlyDictionary<string, object?> payload)
    {
        return System.Text.Json.JsonSerializer.Serialize(payload);
    }

    private static string TrimForPreview(string text, int maxLength = 80)
    {
        if (string.IsNullOrWhiteSpace(text))
        {
            return string.Empty;
        }

        return text.Length <= maxLength
            ? text
            : text[..maxLength] + "…";
    }

    private sealed record ActivityLogItem(string Title, string? Detail, ActivityKind Kind, DateTimeOffset Timestamp);

    private enum ActivityKind
    {
        Assistant,
        Action,
        ToolResult,
        Error
    }

    private void RebuildActivityFromHistory(IReadOnlyList<ChatMessage> historyMessages)
    {
        ActivityLog.Clear();
        foreach (var message in historyMessages)
        {
            switch (message.Role)
            {
                case ChatRole.Assistant:
                    RecordActivity(ActivityKind.Assistant, $"アシスタント: {TrimForPreview(message.Content)}", message.Content);
                    break;
                case ChatRole.Tool:
                    RecordActivity(ActivityKind.ToolResult, $"ツール: {TrimForPreview(message.Content)}", message.Content);
                    break;
            }
        }
    }

    public void Dispose()
    {
        _copilotOptionsSubscription?.Dispose();
        _plcOptionsSubscription?.Dispose();
        _cts?.Dispose();
        AgentState.Changed -= OnAgentStateChanged;
    }

}
